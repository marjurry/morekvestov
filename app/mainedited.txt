# Основные роутеры приложения
'''@app.post("/users/", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, phone_number=user.phone_number)
    if db_user:
        raise HTTPException(status_code=400, detail="Phone number already registered")
    return crud.create_user(db=db, user=user)

@app.get("/users/{phone_number}", response_model=schemas.User)
def read_user(phone_number: int, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, phone_number=phone_number)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@app.get("/users/", response_model=List[schemas.User])
def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_users(db, skip=skip, limit=limit)

# AgeGroup routes
@app.post("/age-groups/", response_model=schemas.AgeGroup, status_code=status.HTTP_201_CREATED)
def create_age_group(age_group: schemas.AgeGroupCreate, db: Session = Depends(get_db)):
    return crud.create_age_group(db=db, **age_group.dict())

@app.get("/age-groups/{age_group_id}", response_model=schemas.AgeGroup)
def read_age_group(age_group_id: int, db: Session = Depends(get_db)):
    db_age_group = crud.get_age_group(db, age_group_id=age_group_id)
    if db_age_group is None:
        raise HTTPException(status_code=404, detail="Age group not found")
    return db_age_group

@app.get("/age-groups/", response_model=List[schemas.AgeGroup])
def read_age_groups(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_age_groups(db, skip=skip, limit=limit)

@app.get("/age-groups/by-age/{age}", response_model=List[schemas.AgeGroup])
def read_age_groups_by_age(age: int, db: Session = Depends(get_db)):
    return crud.get_age_groups_by_age(db, age=age)

# Challenge routes
@app.post("/challenges/", response_model=schemas.Challenge, status_code=status.HTTP_201_CREATED)
def create_challenge(challenge: schemas.ChallengeCreate, db: Session = Depends(get_db)):
    return crud.create_challenge(db=db, **challenge.dict())

@app.get("/challenges/{challenge_id}", response_model=schemas.Challenge)
def read_challenge(challenge_id: int, db: Session = Depends(get_db)):
    db_challenge = crud.get_challenge(db, challenge_id=challenge_id)
    if db_challenge is None:
        raise HTTPException(status_code=404, detail="Challenge not found")
    return db_challenge

@app.get("/challenges/", response_model=List[schemas.Challenge])
def read_challenges(
    skip: int = 0,
    limit: int = 100,
    age_group_id: Optional[int] = None,
    challenge_type: Optional[str] = None,
    location_type: Optional[str] = None,
    min_duration: Optional[int] = None,
    max_duration: Optional[int] = None,
    db: Session = Depends(get_db)
):
    return crud.get_challenges_by_filters(
        db,
        age_group_id=age_group_id,
        challenge_type=challenge_type,
        location_type=location_type,
        min_duration=min_duration,
        max_duration=max_duration
    )

# Quest routes
@app.post("/quests/", response_model=schemas.Quest)
def create_quest(quest: schemas.QuestCreate, db: Session = Depends(get_db)):
    return crud.create_quest(
        db=db,
        id=quest.id,
        user_id=quest.user_id,
        total_duration=quest.total_duration,
        location_type=quest.location_type,
        age_group_id=quest.age_group_id,
        challenge_ids=quest.challenge_ids or []
    )

@app.get("/quests/{quest_id}", response_model=schemas.Quest)
def read_quest(quest_id: int, db: Session = Depends(get_db)):
    db_quest = crud.get_quest(db, quest_id=quest_id)
    if db_quest is None:
        raise HTTPException(status_code=404, detail="Quest not found")
    return db_quest

@app.get("/quests/", response_model=List[schemas.Quest])
def read_quests(
    user_id: Optional[int] = None,
    age_group_id: Optional[int] = None,
    location_type: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: Optional[models.User] = Depends(get_current_user_optional) 
):
    try:
        if current_user:
            return crud.get_quests_by_filters(
                db,
                user_id=current_user.phone_number,  
                age_group_id=age_group_id,
                location_type=location_type
            )
        else:
            return crud.get_quests_by_filters(
                db,
                user_id=user_id,
                age_group_id=age_group_id,
                location_type=location_type
            )
    except HTTPException as e:
        
        if e.status_code in (401, 404):
            raise
        
        raise HTTPException(status_code=400, detail=str(e))'''
'''def read_quests(
    user_id: Optional[int] = None,
    age_group_id: Optional[int] = None,
    location_type: Optional[str] = None,
    db: Session = Depends(get_db)
):
    return crud.get_quests_by_filters(
        db,
        user_id=user_id,
        age_group_id=age_group_id,
        location_type=location_type
    )'''

# Quest-Challenge association routes
'''@app.post("/quests/{quest_id}/challenges/{challenge_id}", status_code=status.HTTP_204_NO_CONTENT)
def add_challenge_to_quest(
    quest_id: int,
    challenge_id: int,
    db: Session = Depends(get_db)
):
    if not crud.add_challenge_to_quest(db, quest_id=quest_id, challenge_id=challenge_id):
        raise HTTPException(status_code=400, detail="Challenge already in quest")

@app.delete("/quests/{quest_id}/challenges/{challenge_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_challenge_from_quest(
    quest_id: int,
    challenge_id: int,
    db: Session = Depends(get_db)
):
    if not crud.remove_challenge_from_quest(db, quest_id=quest_id, challenge_id=challenge_id):
        raise HTTPException(status_code=404, detail="Challenge not found in quest")

@app.get("/quests/{quest_id}/challenges", response_model=List[schemas.ChallengeWithAgeGroup])
def get_quest_challenges(quest_id: int, db: Session = Depends(get_db)):
    return crud.get_quest_challenges(db, quest_id=quest_id)

# Update and delete routes
@app.patch("/users/{phone_number}", response_model=schemas.User)
def update_user(
    phone_number: int, 
    user_update: schemas.UserUpdate, 
    db: Session = Depends(get_db)
):
    db_user = crud.get_user(db, phone_number=phone_number)
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return crud.update_user(db, phone_number=phone_number, update_data=user_update.dict(exclude_unset=True))

@app.delete("/users/{phone_number}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(phone_number: int, db: Session = Depends(get_db)):
    if not crud.delete_user(db, phone_number=phone_number):
        raise HTTPException(status_code=404, detail="User not found")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

@app.patch("/age-groups/{age_group_id}", response_model=schemas.AgeGroup)
def update_age_group(
    age_group_id: int, 
    age_group_update: schemas.AgeGroupUpdate, 
    db: Session = Depends(get_db)
):
    db_age_group = crud.get_age_group(db, age_group_id=age_group_id)
    if not db_age_group:
        raise HTTPException(status_code=404, detail="Age group not found")
    
    return crud.update_age_group(db, age_group_id=age_group_id, update_data=age_group_update.dict(exclude_unset=True))

@app.delete("/age-groups/{age_group_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_age_group(age_group_id: int, db: Session = Depends(get_db)):
    if not crud.delete_age_group(db, age_group_id=age_group_id):
        raise HTTPException(status_code=404, detail="Age group not found")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

@app.patch("/challenges/{challenge_id}", response_model=schemas.Challenge)
def update_challenge(
    challenge_id: int, 
    challenge_update: schemas.ChallengeUpdate, 
    db: Session = Depends(get_db)
):
    db_challenge = crud.get_challenge(db, challenge_id=challenge_id)
    if not db_challenge:
        raise HTTPException(status_code=404, detail="Challenge not found")
    
    return crud.update_challenge(db, challenge_id=challenge_id, update_data=challenge_update.dict(exclude_unset=True))

@app.delete("/challenges/{challenge_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_challenge(challenge_id: int, db: Session = Depends(get_db)):
    if not crud.delete_challenge(db, challenge_id=challenge_id):
        raise HTTPException(status_code=404, detail="Challenge not found")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

@app.patch("/quests/{quest_id}", response_model=schemas.Quest)
def update_quest(
    quest_id: int, 
    quest_update: schemas.QuestUpdate, 
    db: Session = Depends(get_db)
):
    db_quest = crud.get_quest(db, quest_id=quest_id)
    if not db_quest:
        raise HTTPException(status_code=404, detail="Quest not found")
    
    updated_quest = crud.update_quest(db, quest_id=quest_id, update_data=quest_update.dict(exclude_unset=True))
    
    if quest_update.challenge_ids is not None:
        crud.set_quest_challenges(db, quest_id=quest_id, challenge_ids=quest_update.challenge_ids)
    
    db.refresh(updated_quest)
    return updated_quest

@app.delete("/quests/{quest_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_quest(quest_id: int, db: Session = Depends(get_db)):
    if not crud.delete_quest(db, quest_id=quest_id):
        raise HTTPException(status_code=404, detail="Quest not found")
    return Response(status_code=status.HTTP_204_NO_CONTENT)'''

@app.post("/challenges", response_class=HTMLResponse)
async def create_challenge_form(
    request: Request,
    title: str = Form(...),
    description: str = Form(...),
    challenge_type: str = Form(...),
    location_type: str = Form(...),
    duration: int = Form(...),
    age_group_id: int = Form(...),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    try:
        challenge_data = schemas.ChallengeCreate(
            title=title,
            description=description,
            challenge_type=challenge_type,
            location_type=location_type,
            duration=duration,
            age_group_id=age_group_id
        )
        
        challenge = crud.create_challenge(db=db, **challenge_data.dict())
        
        return RedirectResponse(url=f"/challenges/{challenge.id}", status_code=status.HTTP_303_SEE_OTHER)
    except Exception as e:
        age_groups = crud.get_age_groups(db)
        
        return templates.TemplateResponse("challenges/create.html", {
            "request": request,
            "current_user": current_user,
            "age_groups": age_groups,
            "error": str(e)
        })


<script>
document.getElementById('quest-filter-form').addEventListener('submit', function(e) {
    // Отключаем пустые числовые поля перед отправкой
    const numberInputs = this.querySelectorAll('input[type="number"]');
    numberInputs.forEach(input => {
        if (input.value === '') {
            input.disabled = true;
        } else {
            // Валидация значения
            input.value = Math.max(parseInt(input.min), parseInt(input.value) || 0);
        }
    });

    // Отключаем пустые select-поля
    const selects = this.querySelectorAll('select');
    selects.forEach(select => {
        if (select.value === '') {
            select.disabled = true;
        }
    });
});
</script>



АУТЕНТИФИКАЦИЯ
'''@auth_router.post("/register", response_model=schemas.User)
async def register(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # Проверяем существование пользователя
    if crud.get_user(db, user.phone_number):
        raise HTTPException(
            status_code=400,
            detail={"error": "PHONE_EXISTS", "message": "Phone number already registered"}
        )
    
    # Создаем пользователя с хешированием пароля
    db_user = models.User(
        phone_number=user.phone_number,
        is_active=user.is_active
    )
    db_user.set_password(user.password)  # Хешируем пароль
    
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user'''

'''@auth_router.post("/register", response_class=HTMLResponse)
async def register_user_form(
    request: Request,
    phone_number: str = Form(...),
    password: str = Form(...),
    is_active: bool = Form(True),
    db: Session = Depends(get_db)
):
    try:
        if crud.get_user(db, phone_number=int(phone_number)):
            return templates.TemplateResponse("auth/register.html", 
                {"request": request, "error": "Номер телефона уже зарегистрирован"})
        
        user_data = schemas.UserCreate(
            phone_number=int(phone_number),
            password=password,
            is_active=is_active
        )
        
        db_user = models.User(
            phone_number=user_data.phone_number,
            is_active=user_data.is_active
        )
        db_user.set_password(user_data.password)
        
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        
        return RedirectResponse(url="/auth/login", status_code=status.HTTP_303_SEE_OTHER)
    except Exception as e:
        return templates.TemplateResponse("auth/register.html", 
            {"request": request, "error": str(e)})

@auth_router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    login_data: LoginRequest,
    db: Session = Depends(get_db)
):
    user = crud.get_user(db, phone_number=login_data.phone_number)
    if not user or not utils.verify_password(login_data.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    access_token = create_access_token(data={"sub": str(user.phone_number)})
    return {"access_token": access_token, "token_type": "bearer"}

@auth_router.get("/me", response_model=schemas.User)
async def get_current_user_profile(
    current_user: models.User = Depends(get_current_user)
):

    return current_user

@auth_router.post("/logout", response_class=HTMLResponse)
async def logout(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    token_blacklist.add(token)
    response = RedirectResponse(url="/", status_code=status.HTTP_303_SEE_OTHER)
    response.delete_cookie("access_token")
    return response'''




'''@auth_router.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    return templates.TemplateResponse("auth/login.html", {"request": request})

@auth_router.post("/login", response_class=HTMLResponse)
async def login_for_access_token_form(
    request: Request,
    phone_number: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    try:
        user = crud.get_user(db, phone_number=int(phone_number))
        if not user or not utils.verify_password(password, user.password_hash):
            return templates.TemplateResponse("auth/login.html", 
                {"request": request, "error": "Неверный номер телефона или пароль"})
        
        access_token = create_access_token(data={"sub": str(user.phone_number)})
        
        response = RedirectResponse(url="/", status_code=status.HTTP_303_SEE_OTHER)
        response.set_cookie(key="access_token", value=f"Bearer {access_token}", httponly=True)
        return response
    except Exception as e:
        return templates.TemplateResponse("auth/login.html", 
            {"request": request, "error": str(e)})'''

@auth_router.get("/register", response_class=HTMLResponse)
async def register_page(request: Request):
    return templates.TemplateResponse("auth/register.html", {"request": request})

'''@auth_router.post("/register", response_class=HTMLResponse)
async def register_user_form(
    request: Request,
    phone_number: str = Form(...),
    password: str = Form(...),
    is_active: bool = Form(True),
    db: Session = Depends(get_db)
):
    try:
        if crud.get_user(db, phone_number=int(phone_number)):
            return templates.TemplateResponse("auth/register.html", 
                {"request": request, "error": "Номер телефона уже зарегистрирован"})
        
        user_data = schemas.UserCreate(
            phone_number=int(phone_number),
            password=password,
            is_active=is_active
        )
        
        db_user = models.User(
            phone_number=user_data.phone_number,
            is_active=user_data.is_active
        )
        db_user.set_password(user_data.password)
        
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        
        return RedirectResponse(url="/auth/login", status_code=status.HTTP_303_SEE_OTHER)
    except Exception as e:
        return templates.TemplateResponse("auth/register.html", 
            {"request": request, "error": str(e)})'''

ЧТОТО ИЗ МЭЙНА

'''async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> models.User:
    token = credentials.credentials
    if token in token_blacklist:
        raise HTTPException(status_code=401, detail="Token revoked")
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        phone_number = payload.get("sub")
        if not phone_number:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    user = crud.get_user(db, phone_number=int(phone_number))
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user'''

'''async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
    db: Session = Depends(get_db)
) -> Optional[models.User]:
    if not credentials:
        return None
    
    token = credentials.credentials
    if token in token_blacklist:
        raise HTTPException(status_code=401, detail="Token revoked")
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        phone_number = payload.get("sub")
        if not phone_number:
            raise HTTPException(status_code=401, detail="Invalid token")
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    user = crud.get_user(db, phone_number=int(phone_number))
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user'''

'''async def get_current_user(
    request: Request,
    db: Session = Depends(get_db)
) -> Optional[models.User]:
    token = request.cookies.get("access_token")
    if not token or not token.startswith("Bearer "):
        return None
    
    token = token[7:]  # Remove "Bearer "
    
    if token in token_blacklist:
        return None
    
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        phone_number = payload.get("sub")
        if not phone_number:
            return None
    except JWTError:
        return None
    
    return crud.get_user(db, phone_number=int(phone_number))'''


'''@app.get("/users/{phone_number}/edit", response_class=HTMLResponse)
async def edit_user_page(
    request: Request,
    phone_number: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if current_user.phone_number != phone_number:
        raise HTTPException(status_code=403, detail="Недостаточно прав")
    
    return templates.TemplateResponse("users/edit.html", {
        "request": request,
        "current_user": current_user,
        "user": current_user
    })

@app.post("/users/{phone_number}/edit", response_class=HTMLResponse)
async def update_user_form(
    request: Request,
    phone_number: int,
    is_active: bool = Form(...),
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if current_user.phone_number != phone_number:
        raise HTTPException(status_code=403, detail="Недостаточно прав")
    
    try:
        update_data = {"is_active": is_active}
        updated_user = crud.update_user(db, phone_number=phone_number, update_data=update_data)
        
        return RedirectResponse(url="/profile", status_code=status.HTTP_303_SEE_OTHER)
    except Exception as e:
        return templates.TemplateResponse("users/edit.html", {
            "request": request,
            "user": current_user,
            "error": str(e)
        })'''

# Для создания квеста
@auth_router.get("/quests/create", response_class=HTMLResponse)
async def create_quest_page(
    request: Request,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    age_groups = crud.get_age_groups(db)
    challenges = crud.get_challenges(db)
    return templates.TemplateResponse("quests/create.html", {
        "request": request,
        "current_user": current_user,
        "age_groups": age_groups,
        "challenges": challenges
    })

'''@app.post("/quests/{quest_id}", response_class=HTMLResponse)
async def update_quest_form(
    request: Request,
    quest_id: int,
    total_duration: int = Form(...),
    location_type: str = Form(...),
    age_group_id: int = Form(...),
    challenge_ids: List[int] = Form([]),
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user_optional)
):
    try:
        quest = crud.get_quest(db, quest_id=quest_id)
        if not quest:
            raise HTTPException(status_code=404, detail="Квест не найден")
        
        if quest.user_id != current_user.phone_number:
            raise HTTPException(status_code=403, detail="Недостаточно прав")
        
        quest_update = schemas.QuestUpdate(
            total_duration=total_duration,
            location_type=location_type,
            age_group_id=age_group_id,
            challenge_ids=challenge_ids
        )
        
        updated_quest = crud.update_quest(
            db, 
            quest_id=quest_id, 
            update_data=quest_update.dict(exclude_unset=True)
        )
        
        if quest_update.challenge_ids is not None:
            crud.set_quest_challenges(db, quest_id=quest_id, challenge_ids=quest_update.challenge_ids)
        
        return RedirectResponse(url=f"/quests/{quest_id}", status_code=status.HTTP_303_SEE_OTHER)
    except Exception as e:
        age_groups = crud.get_age_groups(db)
        challenges = crud.get_challenges(db)
        quest_challenges = crud.get_quest_challenges(db, quest_id=quest_id)
        quest_challenge_ids = [c.id for c in quest_challenges]
        
        return templates.TemplateResponse("quests/edit.html", {
            "request": request,
            "current_user": current_user,
            "quest": quest,
            "age_groups": age_groups,
            "challenges": challenges,
            "quest_challenge_ids": quest_challenge_ids,
            "error": str(e)
        })'''

НЕУДАЧНЫЕ ЗАДАНИЯ

'''@app.get("/challenges", response_class=HTMLResponse)
async def read_challenges_page(
    request: Request,
    age_group_id: Optional[int] = Query(None),
    challenge_type: Optional[str] = Query(None),
    location_type: Optional[str] = Query(None),
    min_duration: Optional[int] = Query(None),
    max_duration: Optional[int] = Query(None),
    page: int = 1,
    per_page: int = 10,
    db: Session = Depends(get_db),
    current_user: Optional[models.User] = Depends(get_current_user_optional)
):
    # Преобразуем пустые строки в None
    age_group_id = age_group_id if age_group_id else None
    challenge_type = challenge_type if challenge_type else None
    location_type = location_type if location_type else None
    min_duration = min_duration if min_duration else None
    max_duration = max_duration if max_duration else None
    
    # Получаем отфильтрованные задания
    challenges_query = crud.get_challenges_query_by_filters(
        db,
        age_group_id=age_group_id,
        challenge_type=challenge_type,
        location_type=location_type,
        min_duration=min_duration,
        max_duration=max_duration
    )
    
    # Применяем пагинацию
    challenges = challenges_query.offset((page - 1) * per_page).limit(per_page).all()
    total = challenges_query.count()
    
    age_groups = crud.get_age_groups(db)
    
    return templates.TemplateResponse("challenges/list.html", {
        "request": request,
        "current_user": current_user,
        "challenges": challenges,
        "age_groups": age_groups,
        "selected_age_group": age_group_id,
        "challenge_type": challenge_type,
        "location_type": location_type,
        "min_duration": min_duration,
        "max_duration": max_duration,
        "pagination": {
            "page": page,
            "per_page": per_page,
            "total": total,
            "pages": (total + per_page - 1) // per_page
        }
    })'''

'''@app.get("/challenges/{challenge_id}", response_class=HTMLResponse)
async def read_challenge_page(
    request: Request,
    challenge_id: int,
    db: Session = Depends(get_db),
    current_user: Optional[models.User] = Depends(get_current_user_optional)
):
    challenge = crud.get_challenge(db, challenge_id=challenge_id)
    if not challenge:
        raise HTTPException(status_code=404, detail="Задание не найдено")
    
    # Используем правильное имя метода
    quests_with_challenge = crud.get_quests_by_challenge(db, challenge_id=challenge_id)
    
    return templates.TemplateResponse("challenges/detail.html", {
        "request": request,
        "current_user": current_user,
        "challenge": challenge,
        "quests_with_challenge": quests_with_challenge
    })'''

# Обновите роут для списка заданий с пагинацией
'''@app.get("/challenges", response_class=HTMLResponse)
async def read_challenges_page(
    request: Request,
    age_group_id: Optional[int] = None,
    challenge_type: Optional[str] = None,
    location_type: Optional[str] = None,
    min_duration: Optional[int] = None,
    max_duration: Optional[int] = None,
    page: int = 1,
    per_page: int = 10,
    db: Session = Depends(get_db),
    current_user: Optional[models.User] = Depends(get_current_user_optional)
):
    # Получаем отфильтрованные задания
    challenges_query = crud.get_challenges_query_by_filters(
        db,
        age_group_id=age_group_id,
        challenge_type=challenge_type,
        location_type=location_type,
        min_duration=min_duration,
        max_duration=max_duration
    )
    
    # Применяем пагинацию
    challenges = challenges_query.offset((page - 1) * per_page).limit(per_page).all()
    total = challenges_query.count()
    
    age_groups = crud.get_age_groups(db)
    
    return templates.TemplateResponse("challenges/list.html", {
        "request": request,
        "current_user": current_user,
        "challenges": challenges,
        "age_groups": age_groups,
        "selected_age_group": age_group_id,
        "challenge_type": challenge_type,
        "location_type": location_type,
        "min_duration": min_duration,
        "max_duration": max_duration,
        "pagination": {
            "page": page,
            "per_page": per_page,
            "total": total,
            "pages": (total + per_page - 1) // per_page
        }
    })'''

// Для динамической загрузки (если нужно)
async function setupDynamicFiltering() {
    const filterForms = document.querySelectorAll('.dynamic-filter-form');
    
    filterForms.forEach(form => {
        form.addEventListener('change', async function() {
            const formData = new FormData(this);
            const params = new URLSearchParams();
            
            for (const [key, value] of formData.entries()) {
                if (value) params.append(key, value);
            }
            
            const targetElement = document.querySelector(this.dataset.target);
            if (!targetElement) return;
            
            try {
                targetElement.innerHTML = '<div class="text-center my-4"><div class="spinner-border" role="status"><span class="visually-hidden">Загрузка...</span></div></div>';
                
                const response = await fetch(`${this.action}?${params.toString()}`);
                if (!response.ok) throw new Error('Ошибка загрузки');
                
                const html = await response.text();
                targetElement.innerHTML = html;
            } catch (error) {
                targetElement.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
            }
        });
    });
}

// Инициализация
